scalar ObjectId

type Query {
  notes: [Note!]!
  note(id: ObjectId!): NoteResult
  folders(first: Int, after: ObjectId): FoldersConnection!
  folder(id: ObjectId!): FolderResult
}

type Mutation {
  createNote(title: String!, content: String, folderId: ObjectId): NoteResult!
  updateNote(id: ObjectId!, title: String, content: String, folderId: ObjectId): NoteResult
  deleteNote(id: ObjectId!): DeleteResult!
  createFolder(name: String!, parentId: ObjectId): FolderResult!
  updateFolder(id: ObjectId!, name: String, parentId: ObjectId): FolderResult
  deleteFolder(id: ObjectId!): DeleteResult!
}

# ===== UNION TYPES =====
union FolderResult = FolderSuccess | FolderError
union NoteResult = NoteSuccess | NoteError
union DeleteResult = DeleteSuccess | DeleteError

# ===== SUCCESS TYPES =====
type FolderSuccess {
  folder: Folder!
}

type NoteSuccess {
  note: Note!
}

type DeleteSuccess {
  success: Boolean!
}

# ===== ERROR TYPES =====
type FolderError {
  error: FolderErrorType!
}

type NoteError {
  error: NoteErrorType!
}

type DeleteError {
  error: DeleteErrorType!
}

# ===== ERROR ENUMS =====
enum FolderErrorType {
  INVALID_ID
  NOT_FOUND
  VALIDATION_ERROR
  DUPLICATE_NAME
}

enum NoteErrorType {
  INVALID_ID
  NOT_FOUND
  VALIDATION_ERROR
  DUPLICATE_TITLE
}

enum DeleteErrorType {
  INVALID_ID
  NOT_FOUND
}


type Note {
  id: ObjectId!
  title: String!
  content: String
  folder: Folder
  folderId: ObjectId
  createdAt: String!
  updatedAt: String!
}

type Folder {
  id: ObjectId!
  name: String!
  parent: Folder
  parentId: ObjectId
  notes: [Note!]!
  subfolders: [Folder!]!
  createdAt: String!
  updatedAt: String!
}

# ===== PAGINATION TYPES =====
type FoldersConnection {
  edges: [FolderEdge!]!
  pageInfo: PageInfo!
}

type FolderEdge {
  node: Folder!
  cursor: ObjectId!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: ObjectId
  endCursor: ObjectId
}